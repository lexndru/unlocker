# define exit errors constants
SUCCESS=0
FAILURE=1
ERROR_BAD_CALL=100
ERROR_MISSING_DEPS=101
ERROR_EMPTY_FILE=102
ERROR_JUNK_FILE=103
ERROR_NO_SECRETS=104
ERROR_CANNOT_DECRYPT=106
ERROR_CANNOT_CREATE=107
ERROR_RACE_COND=110
ERROR_BAD_ARGUMENTS=120

# set highest debug level available
if [ "x$DEBUG" = "xtrue" ]; then
    set -x -v
fi

# check if the HOME variable is missing
if [ -z "$HOME" ]; then
    echo "Cannot find your user's home directory..." && exit 1
fi

# dependency list
DEPENDENCIES=unlocker python ping cat wc grep sed tr cut tee sshpass

# set path to secrets
SECRETS="$HOME/.unlocker/.secrets"

# set path to encrypted secrets (same directory, different filename)
LOCKED_SECRETS="$SECRETS.lock"

# save current working directory
THIS_DIRECTORY=$(pwd)

# path to temporary directory
TEMP_DIRECTORY=/tmp/.unlocker

# service holder
SERVER_SERVICE=""

# server address holder
SERVER_ADDRESS=""

# passkey holder
PASSKEY=""

# authentification method
AUTH=""

# clean close with error code
close() {
    local EXIT_CODE=0
    if [ $# -eq 1 ]; then
        EXIT_CODE=$1
    fi
    echo "Closing now..." && exit $EXIT_CODE
}

# check if file exists or not
file_exists() {
    if [ -z "$1" ]; then
        close $ERROR_BAD_CALL
    fi
    local EXISTS=$(ls -l "$1" 2> /dev/null | wc -l)
    if [ "$EXISTS" = "0" ]; then
        return $FAILURE
    fi
    return $SUCCESS
}

# check if dependency is installed
is_installed() {
    if [ -x "$(command -v $1)" ]; then
        return $SUCCESS
    fi
    return $FAILURE
}

# decrypt secrets
decrypt_secrets() {
    if ! is_installed gpg; then
        echo "Cannot decrypt secrets because some dependencies are missing:"
        echo "\"gpg\" is NOT installed! Please install \"gpg\" and try again"
        close $ERROR_MISSING_DEPS
    else
        gpg -o "$SECRETS" --decrypt "$LOCKED_SECRETS"
        if [ "$?" != "0" ]; then
            echo "Failed to decrypt secrets..."
            echo "Closing..."
            close $ERROR_CANNOT_DECRYPT
        fi
        rm -f "$LOCKED_SECRETS"
        echo "Secrets are now decrypted"
        return $SUCCESS
    fi
    return $FAILURE
}

# unlock secrets if not already locked
unlock_secrets() {
    local found_secrets="false"
    if file_exists "$SECRETS"; then
        found_secrets="true"
    fi
    if file_exists "$LOCKED_SECRETS"; then
        if [ "x$found_secrets" = "xtrue" ]; then
            echo "Found both plain secrets and encrypted secrets..."
            echo "This should have not happend! Choose how to continue:"
            echo " 1) Use plain secrets and ignore encrypted secrets file"
            echo " 2) Move encrypted secrets file to current directory use plain secrets"
            echo " 3) Use plain secrets and delete encrypted secrets file"
            echo " 4) Decrypt secrets file and overwrite plain secrets"
            echo " 5) Move plain secrets to current directory and decrypt secrets"
            echo " 6) Exit"
            while true; do
                read -p "Type number: " answer
                case $answer in
                    1) {
                        echo "Using plain secrets and ignoring encrypted file..."
                        break
                    }
                    ;;
                    2) {
                        mv "$LOCKED_SECRETS" "$THIS_DIRECTORY/encrypted_secrets"
                        if [ "$?" = "0" ]; then
                            echo "Moved encrypted file to current directory..."
                            break
                        else
                            echo "Failed to move encrypted file to current directory"
                        fi
                    }
                    ;;
                    3) {
                        rm -f "$LOCKED_SECRETS"
                        if [ "$?" = "0" ]; then
                            echo "Removed encrypted file..."
                            break
                        else
                            echo "Failed to remove encrypted file"
                        fi
                    }
                    ;;
                    4) {
                        if decrypt_secrets; then
                            break
                        else
                            echo "Cannot decrypt secrets..."
                        fi
                    }
                    ;;
                    5) {
                        mv "$SECRETS" "$THIS_DIRECTORY/plain_secrets"
                        if [ "$?" = "0" ]; then
                            echo "Moved plain secrets file to current directory..."
                            if decrypt_secrets; then
                                break
                            else
                                echo "Cannot decrypt secrets..."
                            fi
                        else
                            echo "Failed to move plain secrets file to current directory"
                        fi
                    }
                    ;;
                    6) {
                        echo "Preparing to close..."
                        close $SUCCESS
                    }
                    ;;
                    *) {
                        echo "Cannot understand answer... Try again with"
                    }
                    ;;
                esac
            done
        else
            if ! decrypt_secrets; then
                echo "Cannot decrypt secrets..."
                echo "Preparing to close..."
                close $ERROR_CANNOT_DECRYPT
            fi
        fi
    fi
}

# create temporary unlocker file storage
initialize() {
    if file_exists "$TEMP_DIRECTORY"; then
        echo "Temporary directory already exists"
    else
        mkdir -p "$TEMP_DIRECTORY"
        if [ "$?" = "0" ]; then
            echo "Created temporary directory"
        else
            echo "Cannot create temporary directory"
            close $ERROR_CANNOT_CREATE
        fi
    fi
    return $SUCCESS
}

# clean temporary directory
cleanup() {
    rm -rf "$TEMP_DIRECTORY"
    if [ "$?" = "0" ]; then
        echo "Removed temporary directory"
    else
        echo "Cannot remove temporary directory"
        echo "You should remove it manually: $TEMP_DIRECTORY"
    fi
    return $SUCCESS
}

# cleanup on trap
safe_cleanup() {
    echo "Preparing cleanup..." && cleanup
    echo "Closing now..."
    close $SUCCESS
}

# save passkey into holder
save_passkey() {
    if [ "x$DEBUG" = "x*" ]; then
        PASSKEY=$(echo "$@" | unlocker)
    else
        PASSKEY=$(echo "$@" | unlocker 2> /dev/null)
    fi
    if [ "$?" = "0" ]; then
        echo "Got passkey..."
        local pass=$(echo "$PASSKEY" | tr '\n' ' ')
        PASSKEY=$(echo "$pass" | cut -d " " -f2 | python -m base64 -d)
        if [ "$?" != "0" ]; then
            echo "Failed to extract secrets from passkey..."
            return $FAILURE
        fi
        AUTH=$(echo "$pass" | cut -d " " -f1)
        if [ "$?" != "0" ]; then
            echo "Failed to extract authentification from passkey..."
            return $FAILURE
        fi
        return $SUCCESS
    else
        echo "Unable to get passkey..."
        return $FAILURE
    fi
}

# match server name if any
find_server_name() {
    local matches=$(unlocker list | cut -d "|" -f8 | grep "$1" | wc -l)
    if [ "$?" != "0" ]; then
        echo "Error: Something is wrong... cannot match the name of the server"
        close $ERROR_BAD_CALL
    fi
    if [ "$matches" = "0" ]; then
        echo "Nothing found for $1"
        return $FAILURE
    else
        echo "Found $matches possible servers for $1"
        return $SUCCESS
    fi
}

# lookup possible credentials
find_credentials() {
    export NOPAGER=true
    local credentials=$(unlocker list | grep -E "$1 .* $2")
    echo ">>>>..deqdwedfwefwfwfwfwe" $credentials
    # for line in "$credentials"; do
    #     local args=""
    #     local user="$(echo $line | cut -d "|" -f 7 | tr -d " ")"
    #     if [ ! -z "$user" ]; then
    #         args="${args}$user@$2"
    #     else
    #         args="${args}$2"
    #     fi
    #     local port="$(echo $line | cut -d "|" -f 5 | tr -d " ")"
    #     if [ ! -z "$port" ]; then
    #         args="${args}:$port"
    #     fi
    #     echo $args
    #     has_credentials="true"
    # done
    # if [ ]
    # return $SUCCESS
    unset NOPAGER
}

# safely read password
read_password() {
    if [ -z "$1" ]; then
        echo "Missing password holder"
        close $ERROR_BAD_CALL
    fi
    echo -n "Password: "
    read -s $1
    return $SUCCESS
}

# unlock SSH server
unlock_ssh() {
    case $AUTH in
        password) {
            export SSHPASS="$PASSKEY"
            sshpass -e ssh $params
            unset SSHPASS
        }
        ;;
        privatekey) {

        }
        ;;
        *) {
            echo "Unsuported authentification method"
            close $ERROR_BAD_CALL
        }
        ;;
    esac
}

# unlocker wrapper
unlock_server() {
    echo "Trying to unlock $SERVER_ADDRESS..."
    echo "Testing address..."
    ping -q -c 1 $SERVER_ADDRESS
    if [ "$?" = "0" ]; then
        echo "OK, server is online"
    else
        echo "Server is either offline, or bad address given..."
        echo "Testing possible naming patterns"
        if ! find_server_name "$SERVER_ADDRESS"; then
            echo "No records found for this server..."
            read -p "Press any key to continue or ^C to exit " anykey
*        fi
    fi
    echo "Trying to use $SERVER_SERVICE protocol..."
    case $PROTOCOL in
        ssh) {
            echo "Protocol is supported"
            echo "First attempt to get passkey..."
            if ! save_passkey "ssh://$SERVER_ADDRESS"; then
                while true; do
                    echo "Cannot unlock server because no passkey is known"
                    echo "Do you have a password or a private key?"
                    echo " 1) I have a password"
                    echo " 2) I have a private key"
                    echo " 3) I don't have any of these"
                    read -p "Type answer: " auth
                    if [ -z "$auth" ]; then
                        echo "Cannot undersand answer. Try again..."
                    else
                        case $auth in
                            1) {
                                if ! read_password $PASSKEY; then
                                    echo "Cannot read password..."
                                    close $FAILURE
                                else
                                    AUTH="password"
                                    echo "OK, got password!"
                                    break
                                fi
                            }
                            ;;
                            2) {
                                local privatekey
                                read -p "Path to private key: " privatekey
                                if [ ! -f "$privatekey" ]; then
                                    echo "Invalid path to privatekey"
                                else
                                    PASSKEY=$(cat "$privatekey")
                                    AUTH="privatekey"
                                    break
                                fi
                            }
                            ;;
                            3) {
                                echo "Find a password or a private key and try again"
                                close $FAILURE
                            }
                            ;;
                            *) {
                                echo "Cannot undersand answer. Try again..."
                            }
                            ;;
                        esac
                    fi
                done
            fi
            if ! unlock_ssh; then
                echo "Failed to unlock SSH server $SERVER_ADDRESS"
                close $FAILURE
            fi

            passkey=$(get_passkey ssh://$ADDRESS)
            if [ -z "$passkey" ]; then
                echo "Testing all possible credentials..."
                for addr in "$(get_credentials $PROTOCOL $ADDRESS)"; do
                    passkey=$(get_passkey ssh://$addr)
                    if [ ! -z "$passkey" ]; then
                        ADDRESS=$addr
                        break
                    fi
                done
            fi
            params=$(echo $ADDRESS | sed -En 's/(.+)@(.+):(.+)/\1@\2 -p\3/gp')
            if [ -z "$params" ]; then
                params=$ADDRESS
            fi
            if [ "x$DEBUG" = "xssh" -o "x$DEBUG" = "x*" ]; then
                params="-v $params"
            fi
            if [ -z "$passkey" ]; then
                echo "Cannot unlock server because passkey is missing..."
                echo "Recovering..."
                echo "Press any key to continue adding a password or a private key and store"
                echo "it for later use, otherwise exit with ^C or add it to unlocker manually"
                read -p "" anykey
                echo "Choose how to connect:"
                echo "  1) I have a password"
                echo "  2) I have a privatekey"
                echo ""
                read -p "Type number: " auth
                args=$(echo $ADDRESS | sed -En 's/(.+)@(.+):(.+)/-u \1 -h \2 -p \3/pg')
                if [ -z "$args" ]; then
                    args=$(echo $ADDRESS | sed -En 's/(.+)@(.+)/-u \1 -h \2 -p 22/pg')
                    if [ -z "$args" ]; then
                        get_credentials $PROTOCOL $ADDRESS
                        args="-h $ADDRESS -p 22"
                    fi
                fi
                case $auth in
                    1) {
                        args="-a password $args"
                    }
                    ;;
                    2) {
                        args="-a privatekey $args"
                    }
                    ;;
                    *) {
                        echo "Unsuported authentification method..."
                        exit 1
                    }
                    ;;
                esac
                unlocker append $args
                passkey=$(get_passkey ssh://$ADDRESS)
            fi
            password=$(get_password "$passkey")
            if [ -z "$password" ]; then
                privatekey=$(get_private_key "$passkey")
                if [ -z "$privatekey" ]; then
                    echo "Cannot understand authentification method for $ADDRESS"
                    echo "It may not be supported by unlocker or it may corrupted"
                    exit 1
                fi
                secret_file=/tmp/.unlocker/$(date +%s).pk
                echo "$privatekey" > $secret_file
                chmod 0400 $secret_file
                params="-i $secret_file $params"
                is_installed ? ssh
                ssh $params
            else
                is_installed ? sshpass
                export SSHPASS="$password"
                sshpass -e ssh $params
                unset SSHPASS
            fi
        }
        ;;
        *) {
            echo "Error: $SERVER_SERVICE is not supported by Unlocker"
            if is_installed "$SERVER_SERVICE"; then
                echo "$SERVER_SERVICE is installed on your system"
                echo "Help by submitting an implementation or a request at $HOMEPAGE"
            fi
            close $FAILURE
        }
        ;;
    esac
    echo "Preparing to close..."
    echo "Successfully closed connection to $SERVER_ADDRESS..."
}

# output a help message
if [ "x$1" = "xhelp" -o "x$1" = "x" ]; then
    echo "              _            _             "
    echo "  _   _ _ __ | | ___   ___| | _____ _ __ "
    echo " | | | | '_ \| |/ _ \ / __| |/ / _ \ '__|"
    echo " | |_| | | | | | (_) | (__|   <  __/ |   "
    echo "  \__,_|_| |_|_|\___/ \___|_|\_\___|_|   "
    echo ""
    echo "Unlocker v$VERSION $(uname -op)"
    echo ""
    echo "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"
    echo "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"
    echo "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE"
    echo "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"
    echo "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"
    echo "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE"
    echo "SOFTWARE."
    echo ""
    echo "  Please report bugs at $HOMEPAGE"
    echo ""
    echo "Usage:"
    echo "  service [user@]host[:port]  - Unlock server if credentials are known"
    echo ""
    echo "Examples:"
    echo "  redis 127.0.0.1:6379        - Connect to local Redis with an available user"
    echo "  mysql 127.0.0.1             - Connect to MySQL with any available user"
    echo "  mysql guest@database:3306   - Connect to MySQL on port 3306 with user guest"
    echo "  ssh root@yourserver.tld     - Connect to yourserver.tld with root user"
    echo "  ssh yourserver.tld          - Connect to yourserver.tld with available user"
    echo ""
    exit 0
fi

# check if all arguments are provided
if [ -z "$2" ]; then
    echo "Required arguments are missing: see \"unlock help\" for examples"
    close $ERROR_BAD_ARGUMENTS
fi

# autodetect secrets file and decrypt if needed
unlock_secrets

# double check if secrets file exist
if ! file_exists "$SECRETS"; then
    echo "Warning: Cannot find secrets on this system"
    echo "Warning: Either unlocker has not been initialized, either secrets are missing"
    echo "Warning: Preparing to close..."
    close $ERROR_RACE_COND
fi

# check if all needed dependencies are installed
for app in $DEPENDENCIES; do
    if ! is_installed $app; then
        close $ERROR_MISSING_DEPS
    fi
done

# setup ^C trap
trap safe_cleanup 2 3

# save service
SERVER_SERVICE=$1

# save server address
SERVER_ADDRESS=$2

# prepare to unlock
if ! initialize; then
    echo "Cannot initialize script..."
    close $ERROR_BAD_CALL
fi

# unlock server
unlock_service $@

# cleanup
cleanup
